  "module_stdout": "{\"failed\": false, \"changed\": false, \"msg\": \"Done with 0 pvmoves\", \"segmap_before\": \"  LV       Start SSize LE Ranges               \\n  rootVol      0  1792 /dev/nvme0n1p2:0-1791   \\n  swapVol   1792   256 /dev/nvme0n1p2:1792-2047\\n  homeVol   2048   512 /dev/nvme0n1p2:2048-2559\\n  varVol    2560  1536 /dev/nvme0n1p2:2560-4095\\n  logVol    4096   512 /dev/nvme0n1p2:4096-4607\\n  auditVol  4608   256 /dev/nvme0n1p2:4608-4863\\n  dataVol   4864   256 /dev/nvme0n1p2:4864-5119\\n  varVol    5120   512 /dev/nvme0n1p2:5120-5631\\n            5632  7048                         \", segmap_done\": \"  LV       Start SSize LE Ranges               \\n  rootVol      0  1792 /dev/nvme0n1p2:0-1791   \\n  swapVol   1792   256 /dev/nvme0n1p2:1792-2047\\n  homeVol   2048   512 /dev/nvme0n1p2:2048-2559\\n  varVol    2560  1536 /dev/nvme0n1p2:2560-4095\\n  logVol    4096   512 /dev/nvme0n1p2:4096-4607\\n  auditVol  4608   256 /dev/nvme0n1p2:4608-4863\\n  dataVol   4864   256 /dev/nvme0n1p2:4864-5119\\n  varVol    5120   512 /dev/nvme0n1p2:5120-5631\\n            5632  7048                         \", \"myenv\": [\"XDG_SESSION_ID=7\",\r\n\"TERM=xterm\",\r\n\"SHELL=/bin/bash\",\r\n\"USER=root\",\r\n\"LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:\",\r\n\"SUDO_USER=ec2-user\",\r\n\"SUDO_UID=1000\",\r\n\"USERNAME=root\",\r\n\"MAIL=/var/mail/ec2-user\",\r\n\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\r\n\"_=/bin/env\",\r\n\"PWD=/home/ec2-user\",\r\n\"LANG=en_US.UTF-8\",\r\n\"HOME=/root\",\r\n\"SUDO_COMMAND=/bin/sh -c echo BECOME-SUCCESS-ugiqjmtqzogaehgqmlrvapfipuugaswk ; /bin/bash /home/ec2-user/.ansible/tmp/ansible-tmp-1728584332.7526026-112-270479179890624/AnsiballZ_pvsqueeze /home/ec2-user/.ansible/tmp/ansible-tmp-1728584332.7526026-112-270479179890624/args\",\r\n\"SHLVL=2\",\r\n\"LOGNAME=root\",\r\n\"SUDO_GID=1000\"]}",
#!/bin/bash
#
# pvsqueeze - Squeeze extents into free holes
#
# This script iteratively moves linear (allocated to LV) extents to fill in
# free holes found in a PV segement map. The end result is that all free
# extents are at the end of the PV.
#
# The script is a lovely example of a bash Ansible module, that is, it reads in
# args from a file passed from Ansible, does its work, and lastly passes the
# result back to Ansible as JSON output.
#

# Sanitize strings for JSON output
jwash () {
  echo -n "$*" | python -c 'import json,sys; print(json.dumps(sys.stdin.read()))'
}

# Debug env vars
myenv="[$(env | while read e; do echo -n "$(jwash "$e"),"; done)"
myenv="${myenv%?}]"

# Ansible input args are set here
source "$1"

# Check for required arg pv
if [[ ! $pv ]]; then
  printf '{"failed": true, "msg": "missing required arguments: pv"}'
  exit 1
fi

# Check that pv is really a PV
pvcheck="$(pvs "$pv" 2>&1)"
if [[ $? -ne 0 ]]; then
  printf '{"failed": true, "msg": %s}' "$(jwash pvs error: $pvcheck)"
  exit 1
fi

# Get before segment map
segmap_before="$(pvs "$pv" --segments -o lvname,pvseg_start,pvseg_size,seg_le_ranges 2>&1)"

# Iterate stuffing PEs in each free hole
pvsargs='--noheadings --nameprefixes --segments -o pvseg_start,pvseg_size,segtype'
moves=0
changed=false
while true; do
  # Find first free segment
  LVM2_PVSEG_START=
  eval $(pvs "$pv" $pvsargs | grep SEGTYPE=.free. | head -1)
  if [[ -z $LVM2_PVSEG_START ]]; then
    printf '{"failed": true, "msg": "no free segments found"}'
    exit 1
  fi
  free_start=$LVM2_PVSEG_START
  free_size=$LVM2_PVSEG_SIZE

  # Find the last linear segment
  LVM2_PVSEG_START=
  eval $(pvs "$pv" $pvsargs | grep SEGTYPE=.linear. | tail -1)
    if [[ -z $LVM2_PVSEG_START ]]; then
    printf '{"failed": true, "msg": "no linear segments found"}'
    exit 1
  fi
  move_start=$LVM2_PVSEG_START
  move_size=$LVM2_PVSEG_SIZE

  # We're done when first free is after the last linear
  [[ $free_start -gt $move_start ]] && break

  # Move last linear PEs to the free segment
  ((moves++))
  changed=true
  from_range="$pv:$((move_start+move_size-free_size))-$((move_start+move_size-1))"
  to_range="$pv:$((free_start))-$((free_start+free_size))"
  moveout="$(pvmove --atomic --alloc anywhere "$from_range" "$to_range" 2>&1)"
  if [[ $? -ne 0 ]]; then
    printf '{"failed": true, "msg": %s}' "$(jwash pvmove $from_range $to_range error: $moveout)"
    exit 1
  fi
done

# Get after segment map
segmap_done="$(pvs "$pv" --segments -o lvname,pvseg_start,pvseg_size,seg_le_ranges 2>&1)"

# Output JSON results
printf '{"failed": false, "changed": '$changed', "msg": "Done with '$moves' pvmoves", "segmap_before": %s, segmap_done": %s, "myenv": %s}' "$(jwash "$segmap_before")" "$(jwash "$segmap_done")" "$myenv"

exit 0
